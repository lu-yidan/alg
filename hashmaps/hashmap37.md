关于solve的解释：

这个函数首先遍历数独的每一个空格。对于每一个空格，它尝试填充数字1到9。如果填充的数字是有效的（即没有违反数独的规则），那么它就递归地调用solve函数，尝试填充下一个空格。这就是DFS的部分，它会深入到数独的每一个空格，尝试所有可能的数字。

如果在填充一个空格后，后续的空格无法被有效地填充，那么它就会撤销当前的填充（将当前空格重新设置为'.'），然后尝试下一个数字。这就是所谓的回溯。

如果所有的数字都无法被填充到当前的空格，那么函数返回false，表示需要回溯到前一个空格。

如果所有的空格都被有效地填充，那么函数返回true，表示已经找到一个有效的解。

这个函数的时间复杂度是O(9^m)，其中m是数独中空格的数量。因为每一个空格有9种可能的数字，所以总共有9^m种可能的填充方式。在最坏的情况下，这个函数需要尝试所有的填充方式。

关于isValid的解释：

if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false; // Check 3*3 block
这行代码是用来检查一个3x3的数独子块是否已经包含了字符c。如果包含了，那么就返回false，表示当前字符c不能放在这个位置。

让我们来详细解释一下这个表达式： 3 * (row / 3) + i / 3 和 3 * (col / 3) + i % 3

这两个表达式的目的是为了遍历当前单元格所在的3x3子块。这个子块的左上角的坐标是(3 * (row / 3), 3 * (col / 3))。

row / 3 和 col / 3 是用来确定当前单元格在哪一个大的3x3区域内。乘以3是为了获取这个大区域的起始行和列。

i / 3 和 i % 3 是用来遍历这个3x3区域内的9个单元格。i / 3 产生的结果是0, 0, 0, 1, 1, 1, 2, 2, 2，i % 3 产生的结果是0, 1, 2, 0, 1, 2, 0, 1, 2。这样就能遍历3x3区域内的所有单元格。

所以，board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] 就能遍历当前单元格所在的3x3子块的所有单元格。如果其中有任何一个单元格的值等于c，就返回false。

作者：鲁大仙
链接：https://leetcode.cn/problems/sudoku-solver/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。